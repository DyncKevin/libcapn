{
  "name": "Libcapn",
  "tagline": "A simple C Library for interact with the Apple Push Notification Service (APNs)",
  "body": "# libcapn\r\n\r\n[![Build Status](http://img.shields.io/travis/adobkin/libcapn.svg?style=flat&branch=master)](http://travis-ci.org/adobkin/libcapn) [![MIT](http://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://github.com/adobkin/libcapn/blob/master/LICENSE)\r\n\r\nlibcapn is a C Library to interact with the [Apple Push Notification Service](http://developer.apple.com/library/mac/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html) (APNs for short) using simple and intuitive API.\r\nWith the library you can easily send push notifications to iOS and OS X (>= 10.8) devices.\r\n\r\n__Version 2.0 isn't compatible with 1.0__\r\n\r\n## Table of Contents\r\n\r\n<!-- toc -->\r\n* [Installation](#installation)\r\n  * [on *nix](#on-nix)\r\n  * [on Windows](#on-windows)\r\n* [Quick Start](#quick-start)\r\n  * [Initialize and configure context](#initialize-and-configure-context)\r\n    * [Logging](#logging)\r\n    * [Connection](#connection)\r\n  * [Sending notifications](#sending-notifications)\r\n    * [The notification payload](#the-notification-payload)\r\n    * [Tokens](#tokens)\r\n    * [Send](#send)\r\n  * [Example](#example)\r\n* [apn-pusher](#apn-pusher)\r\n\r\n<!-- toc stop -->\r\n## Installation\r\n\r\n### on *nix\r\n\r\n__Requirements__\r\n\r\n- [CMake](http://cmake.org) >= 2.8.5\r\n- Clang 3 and later or GCC 4.6 and later\r\n- make\r\n\r\n__Build instructions__\r\n\r\n```sh\r\n$ git clone https://github.com/adobkin/libcapn.git\r\n$ git submodule update --init\r\n$ mkdir build\r\n$ cd build\r\n$ cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../\r\n$ make\r\n$ sudo make install\r\n```\r\n\r\n### on Windows\r\n\r\n__Requirements__\r\n\r\n- [Microsoft Visual Studio 2015](https://www.visualstudio.com)\r\n- [CMake](http://cmake.org) >= 2.8.5\r\n- [Visual C++ Redistributable for Visual Studio 2015](https://www.microsoft.com/en-us/download/details.aspx?id=48145)\r\n\r\n__Build instructions__\r\n\r\n1. [Download](https://github.com/adobkin/libcapn/releases/latest) the latest source archive from [GitHub](https://github.com/adobkin/libcapn/releases/latest) and extract it somewhere on your disk, e.g. `C:\\libcapn`\r\n\r\n2. Open command console (Win-R ==> \"cmd\" => Enter)\r\n\r\n3. Go to the libcapn directory and run `win_build\\build.bat`\r\n\r\n```sh\r\ncd C:\\libcapn\r\nwin_build\\build.bat\r\n```\r\n\r\n## Quick Start\r\n\r\nFirst, initialize the library by calling `apn_library_init()`. This function must be called at least once before any calls to other `libcapn` functions. Because `apn_library_init()` is not thread-safe, you must not call it while any other thread in the program is running. The reason is that\r\n`apn_library_init()` calls initialization functions of SSL library that are not thread-safe.\r\n\r\n### Initialize and configure context\r\n\r\nCreate a new apn `context` and specify the path to a certificate file and the path to a private key file using `apn_set_certificate()`.\r\nIf the private key is password protected, pass it as well, otherwise pass `NULL`. The Certificate and the private key must be in PEM format.\r\nAn alternative way is to use a .p12 file instead of a certificate and a private key. Use `apn_set_pkcs12_file()` to specify the path to a .p12 file .\r\nIf a .p12 file is specified, certificate and private key will be ignored.\r\n\r\n```c\r\napn_ctx_t *ctx = apn_init();\r\nif(!ctx) {\r\n\t// error\r\n}\r\n\r\n// Uses certificate and private key (in PEM format)\r\napn_set_certificate(ctx, \"push_test.pem\", \"push_test_key.pem\", \"12345678\");\r\n\r\n// Uses .p12 file\r\napn_set_pkcs12_file(ctx, \"push_test.p12\", \"123\");\r\n```\r\n\r\nBy default the library uses production environment to interact with Apple Push Notification Service (APNs). Call `apn_set_mode()` passing `APN_MODE_SANDBOX` to\r\nuse sandbox environment.\r\n\r\n>Certificate and private key (or .p12 file) must conform to the specified mode, otherwise the notifications will not be\r\ntransported to the device.\r\n\r\n```c\r\n apn_set_mode(ctx,  APN_MODE_SANDBOX);\r\n```\r\n\r\nTo specify behavior call `apn_set_behavior()`. Function takes one or more bit flags as a parameter:\r\n\r\n```c\r\n apn_set_behavior(apn_ctx, APN_OPTION_RECONNECT | APN_OPTION_LOG_STDERR);\r\n ```\r\n\r\nAvailable flags:\r\n\r\n - `APN_OPTION_RECONNECT` -  Automatically establish new connection when connection is dropped. \r\n - `APN_OPTION_LOG_STDERR` - Print log messages to standard error\r\n\r\n#### Logging\r\n\r\nFor logging specify log level and pointer to callback-function using `apn_set_log_level()` and `apn_set_log_callback()`:\r\n\r\n```c\r\nvoid logfunc(apn_log_level level, const char * const message, uint32_t len) {\r\n    printf(\"======> %s\\n\", message);\r\n}\r\n\r\napn_set_log_level(ctx, APN_LOG_LEVEL_INFO | APN_LOG_LEVEL_ERROR | APN_LOG_LEVEL_DEBUG);\r\napn_set_log_callback(ctx, logfunc);\r\n\r\n```\r\n\r\n#### Connection\r\n\r\nTo establishes connection to the APNs, calling `apn_connect()`:\r\n\r\n```c\r\nif(APN_ERROR == apn_connect(ctx)) {\r\n\tprintf(\"Could not connected to Apple Push Notification Service: %s (errno: %d)\\n\", apn_error_string(errno), errno);\r\n\t// error\r\n}\r\n```\r\n\r\n### Sending notifications\r\n\r\n#### The notification payload\r\n\r\nEvery remote notification includes a payload. The payload contains information about how the system should alert\r\nthe user as well as any custom data you provide.\r\n\r\nTo create a payload you need to use `apn_payload_init()`; to set general properties of the payload, use `apn_payload_set_*()` functions. You can also specify\r\ncustom properties using `apn_payload_add_custom_property_*()` functions:\r\n\r\n\r\n```c\r\napn_payload_t *payload = apn_payload_init();\r\nif(!payload) {\r\n\tprintf(\"Unable to init payload: %s (%d)\\n\", apn_error_string(errno), errno);\r\n\t// error\r\n}\r\n\r\napn_payload_set_badge(payload, 10);           \r\napn_payload_set_body(payload, \"Test Push Message\");\r\n\r\n// Custom property\r\napn_payload_add_custom_property_integer(payload, \"custom_property_integer\", 100);\r\n...\r\n```\r\n\r\n>In iOS 8 and later, the maximum size allowed for a payload is 2 kilobytes; prior to iOS 8\r\nand in OS X, the maximum payload size is 256 bytes. APNs rejects any notification that exceeds this limit.\r\n\r\nA payload may contain the `content-available` property. If this property is set to a value of 1, it lets the remote notification act as a “silent”\r\nnotification. When a silent notification arrives, iOS wakes up your app in the background so that you can get new data from your server or do background\r\ninformation processing. Users aren’t told about the new or changed information that results from a silent notification.\r\n\r\nBy default the library uses default priority to notifications. Call `apn_payload_set_priority()`, passing `APN_NOTIFICATION_PRIORITY_HIGH`\r\nto use high priority:\r\n\r\n```c\r\napn_payload_set_priority(payload, APN_NOTIFICATION_PRIORITY_HIGH);\r\n```\r\n\r\nWhen you set high priority, notifications are sent immediately to devices. The notification must trigger an alert, sound, or badge\r\non the device. It is an error to use this priority for a push that contains only the `content-available` key. When you set default priority, notifications are sent at a time that\r\nconserves power on the device receiving them.\r\n\r\n#### Tokens\r\n\r\nNext, create array of tokens and add the device tokens as either a hexadecimal string to array:\r\n\r\n```c\r\napn_array_t *tokens = apn_array_init(2, NULL, NULL);\r\nif(tokens) {\r\n    apn_array_insert(tokens, \"XXXXXXXX\");\r\n    apn_array_insert(tokens, \"YYYYYYYY\");\r\n    apn_array_insert(tokens, \"ZZZZZZZZ\");\r\n}\r\n```\r\n\r\n>Each push environment will issue a different token(s) for the same device or computer. The device token(s) for production\r\nis different from the development one. If you are using a production mode, you must use a production token(s) and vice versa\r\n\r\n#### Send\r\n\r\nTo send notification to devices call `apn_send()`, passing `context`, `payload`, array of device `tokens` and pointer to a invalid tokens array. The array should be freed - call `apn_array_free()`:\r\n\r\n```c\r\n\r\napn_array_t *invalid_tokens = NULL;\r\n\r\nif(APN_ERROR == apn_send(ctx, payload, tokens, &invalid_tokens))  {\r\n\t\tprintf(\"Could not sent push: %s (errno: %d)\\n\", apn_error_string(errno), errno)\r\n} else {\r\n    if (invalid_tokens) {\r\n        printf, \"Invalid tokens:\\n\");\r\n        uint32_t i = 0;\r\n        for (; i < apn_array_count(invalid_tokens); i++) {\r\n            printf(\"    %u. %s\\n\", i, apn_array_item_at_index(invalid_tokens, i));\r\n        }\r\n        apn_array_free(invalid_tokens);\r\n    }\r\n}\r\n```\r\n\r\n> The APNs drops the connection if it receives an invalid token. You'll need to reconnect and send notification to token(s)\r\nfollowing it, again.\r\n\r\nIf flag `APN_OPTION_RECONNECT` is specified, the `apn_send()` automatically establishes new connection to APNs when connection is dropped\r\n\r\nAdvanced, you can take invalid token, just specify a pointer to callback-function using `apn_set_invalid_token_callback`:\r\n\r\n```c\r\nvoid invalid_token(const char * const token, uint32_t index) {\r\n    printf(\"======> Invalid token: %s (index: %d)\\n\", token, index);\r\n}\r\n\r\n...\r\n\r\napn_ctx_t *ctx = ...\r\napn_set_invalid_token_callback(ctx, invalid_token);\r\n```\r\n\r\nThe callback function will be called for each invalid token. Function has the following prototype:\r\n\r\n```c\r\nvoid (*invalid_token_callback)(const char * const token, uint32_t index)\r\n```\r\n\r\n### Example\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <errno.h>\r\n#include <assert.h>\r\n#include <capn/apn.h>\r\n\r\nvoid __apn_logging(apn_log_levels level, const char * const message, uint32_t len) {\r\n    printf(\"======> %s\\n\", message);\r\n}\r\n\r\nvoid __apn_invalid_token(const char * const token, uint32_t index) {\r\n    printf(\"======> Invalid token: %s (index: %d)\\n\", token, index);\r\n}\r\n\r\nint main() {\r\n    apn_payload_t *payload = NULL;\r\n    apn_ctx_t *ctx = NULL;\r\n    time_t time_now = 0;\r\n    char *invalid_token = NULL;\r\n\r\n    assert(apn_library_init() == APN_SUCCESS);\r\n\r\n    time(&time_now);\r\n\r\n    if(NULL == (ctx = apn_init())) {\r\n        printf(\"Unable to init context: %d\\n\", errno);\r\n        apn_library_free();\r\n        return -1;\r\n    }\r\n\r\n    apn_set_pkcs12_file(ctx, \"push_test.p12\", \"12345678\");\r\n    apn_set_mode(ctx,  APN_MODE_SANDBOX); //APN_MODE_PRODUCTION or APN_MODE_SANDBOX\r\n    apn_set_behavior(ctx, APN_OPTION_RECONNECT);\r\n    apn_set_log_level(ctx, APN_LOG_LEVEL_INFO | APN_LOG_LEVEL_ERROR | APN_LOG_LEVEL_DEBUG);\r\n    apn_set_log_callback(ctx, __apn_logging);\r\n    apn_set_invalid_token_callback(ctx, __apn_invalid_token);\r\n\r\n    if(NULL == (payload = apn_payload_init())) {\r\n        printf(\"Unable to init payload: %d\\n\", errno);\r\n        apn_free(ctx);\r\n        apn_library_free();\r\n        return -1;\r\n    }\r\n\r\n    apn_payload_set_badge(payload, 10); // Icon badge\r\n    apn_payload_set_body(payload, \"Test Push Message\");  // Notification text\r\n    apn_payload_set_expiry(payload, time_now + 3600); // Expires\r\n    apn_payload_set_priority(payload, APN_NOTIFICATION_PRIORITY_HIGH);  // Notification priority\r\n    apn_payload_add_custom_property_integer(payload, \"custom_property_integer\", 100); // Custom property\r\n\r\n    apn_array_t *tokens = apn_array_init(2, NULL, NULL);\r\n    if(!tokens) {\r\n        apn_free(ctx);\r\n        apn_payload_free(payload);\r\n        apn_library_free();\r\n        return -1;\r\n    }\r\n\r\n    apn_array_insert(tokens, \"XXXXXXXX\");\r\n    apn_array_insert(tokens, \"YYYYYYYY\");\r\n    apn_array_insert(tokens, \"ZZZZZZZZ\");\r\n\r\n    if(APN_ERROR == apn_connect(ctx)) {\r\n        printf(\"Could not connect to Apple Push Notification Service: %s (errno: %d)\\n\", apn_error_string(errno), errno);\r\n        apn_free(ctx);\r\n        apn_payload_free(payload);\r\n        apn_array_free(tokens);\r\n        apn_library_free();\r\n        return -1;\r\n    }\r\n\r\n    apn_array_t *invalid_tokens = NULL;\r\n    int ret = 0;\r\n    if (APN_ERROR == apn_send(ctx, payload, tokens, &invalid_tokens)) {\r\n        printf(\"Could not send push: %s (errno: %d)\\n\", apn_error_string(errno), errno);\r\n        ret = -1;\r\n    } else {\r\n        printf(\"Notification was successfully sent to %u device(s)\\n\",\r\n            apn_array_count(tokens) - ((invalid_tokens) ? apn_array_count(invalid_tokens) : 0));\r\n        if (invalid_tokens) {\r\n    \t    printf(\"Invalid tokens:\\n\");\r\n    \t    uint32_t i = 0;\r\n    \t    for (; i < apn_array_count(invalid_tokens); i++) {\r\n    \t        printf(\"    %u. %s\\n\", i, apn_array_item_at_index(invalid_tokens, i));\r\n    \t    }\r\n    \t    apn_array_free(invalid_tokens);\r\n    \t}\r\n    }\r\n\r\n    apn_free(ctx);\r\n    apn_payload_free(payload);\r\n    apn_array_free(tokens);\r\n    apn_library_free();\r\n\r\n    return ret;\r\n}\r\n\r\n```\r\n\r\n## apn-pusher\r\n\r\napn-pusher - simple command line tool to send push notifications to iOS and OS X devices:\r\n\r\n```sh\r\napn-pusher -c ./test_push.p12 -p -d -m 'Test' -t 1D2EE2B3A38689E0D43E6608FEDEFCA534BBAC6AD6930BFDA6F5CD72A808832B:1D2EE2B3A38689E0D43E6608FEDEFCA534BBAC6AD6930BFDA6F5CD72A808832A\r\n```\r\n\r\n```sh\r\napn-pusher -c ./test_push.p12 -p -d -m 'Test' -T ./tokens.txt -v\r\n```\r\n\r\nOptions:\r\n\r\n```sh\r\nUsage: apn-pusher [OPTION]\r\n    -h Print this message and exit\r\n    -c Path to .p12 file (required)\r\n    -p Passphrase for .p12 file. Will be asked from the tty\r\n    -d Use sandbox mode\r\n    -m Body of the alert to send in notification\r\n    -a Indicates content available\r\n    -b Badge number to set with notification\r\n    -s Name of a sound file in the app bundle\r\n    -i Name of an image file in the app bundle\r\n    -y Category name of notification\r\n    -t Tokens, separated with ':' (required)\r\n    -T Path to file with tokens\r\n    -v Make the operation more talkative\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}